\documentclass[a4paper,draft]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{arrows, positioning}
\usepackage{pgf-umlcd}
\title{Entwicklerdokumentation pyPsy}
\author{Franz Gregor und Alexandra Weiss}
\date{\today}
\makeindex

\begin{document}
\pagenumbering{arabic}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Beschreibung}
Die Aufgabe von pyPsy ist es, den Benutzer bei der Verwertung von Eyetracking Daten zu untersützen. Konkret wird der von der Besuchsperson betrachtete Punkt als farbiges Overlay in das Video gezeichnet, sodass eine Auswertung in Form einer Kategorisierung durchgeführt werden kann. Dabei wird die Kategorisierung der betrachteten Gegenstände in pyPsy eingetragen und kann dann als csv-Datei abgespeichert werden, wodurch eine genaue Aufschlüsselung der Häufigkeiten möglich ist. 
Um die Augenbewegungsdaten in pyPsy auslesen zu können, müssen diese vorher in eine *.asc Datei exportiert werden. Liegt eine solche Datei für ein Video vor, so können beide Dateien in pyPsy geladen und bearbeitet werden.
Innerhalb einer *.asc Datei gibt es mehrere Trials, die gesondert voneinander betrachtet werden.

\section{Architektur}
pyPsy ist eine multiprocessing Anwendung.
Das bedeuted das mehrere unabh\"angige Prozesse miteinander arbeiten um die gesamte Funktionalit\"at bereit zu stellen.
Wir haben uns f\"uer diese Architektur entscheiden, weil in einem Videoplayer mindestens zwei ???PROGRAMML\"aufe existieren, ein WiedergabePROZESS, der das Video "abspielt" und ein PROZESS der auf Aktionen des Benutzers reagiert (Wiedergabe stoppen, etc.), und w\"arend der Machbarkeitsuntersuchungen hat sich herausgestellt, dass diese PROZESSE in Python nicht durch Threads repr\"asentiert werden k\"oennen.
Der Grund daf\"ur liegt in der Implementierung von Threads in Python per GIL("`Global Interpreter Lock'") und der daraus resultierenden nicht ausreichenden Performance der Threadingl\"osung.

Wir trennen die Anwendung in zwei Prozesse mit jeweils unterschiedlichen Aufgaben auf.
Der erste Prozess k\"ummert sich um die Nutzerinterarktion und damit haupts\"achlich um die GUI.
Der zweite Prozess \"ubernimmt die fachlichen Aufgaben. Das sind z.B. das Videobild samt Overlay bereitstellen oder die Kategoriesierungen verwalten und exportieren.
Der erste Prozess wird nachfolgend GUI-Prozess, der zweite Prozess Backend-Prozess genannt.
Die Programmkontrolle geht in aller Regel vom GUI-Prozess aus.
In den folgenden Abschnitten wird die Controller Komponente n\"aher beschrieben.
Diese ist gewisserma\ss en das Interface zum Backend-Prozess.

\section{Komponenten}
In diesem Abschnitt werden die wichtigsten Komponenten von pyPsy und deren Interaktion beschrieben.

\subsection{GUI}
Die folgenden Komponenten stellen die GUI oder ihre Elemente bereit und werden im GUI-Prozess ausgef\"uhrt.
Diese Liste ist nicht vollst\"andig.
Sie betrachtet nur die interessantesten Konzepte.

\subsubsection{MainFrame}
Ist das ein und alles

\subsubsection{CategoryList}

\subsection{Backend}
Die Komponenten in diesem Abschnitt werden im Backend genutzt.
Das hei\"\ss t sie stellen die fachliche Funktionalit\"at her.

\subsubsection{Controller}
  Der Controller spielt eine sehr zentrale Rolle in pyPsy, da er die Schnittstelle zwischen GUI und den funktionalen Klassen bildet. Im Sinne des Design Patterns "`Model-View-Controller"' bedeutet dies, dass Klassen, die die GUI verwalten auf beispielsweise die Clock nur über den Controller zugreifen können. Im Folgenden ist der Zugriff der GUI-Klassen auf den Controller beziehungsweise der funktionalen Klassen auf den Controller dargestellt.
  \begin{figure}[ht]
    \begin{center}
    \begin{tikzpicture}[auto, node distance=1.2cm]
      \node (controller) {Controller};    
      \node[right=2.2cm of controller] (clock) {Clock};
      \node[above of=clock] (categories) {CategoryContainer};
      \node[above of=categories] (eyes) {EyeMovement};
      \node[above of=eyes] (saveable) {Saveable};  
      \node[below of=clock] (vid_reader) {VideoReader};
      \node[below of=vid_reader] (vid_writer) {VideoWriter};
      \node[below of=vid_writer] (cfg) {Config};
      \node[below of=cfg] (help) {Helper};
        
      \node[left=2.2cm of controller](mainframe) {MainFrame};     
      \node[above of= mainframe] (editcatdlg) {EditCategoryDialog};
      \node[above of= editcatdlg] (catdlg) {CategoryDialog};
      \node[above of= catdlg] (opendlg) {OpenDialog};
      
      \node[below of= mainframe] (categorylist) {CategoryList};      
      \node[below of= categorylist] (strimage) {StringImage};
      \node[below of= strimage] (cursors) {images};

      \path
	(controller) edge (clock)
	(controller) edge (vid_reader)
	(controller) edge (vid_writer)
	(controller) edge (eyes)
	(controller) edge (categories)
	(controller) edge (cfg)
	(controller) edge (help)
	(controller) edge (saveable)
	(controller) edge (mainframe)
	(controller) edge (categorylist)
	(controller) edge (opendlg)
	(controller) edge (catdlg)
	(controller) edge (editcatdlg)
	(controller) edge (strimage)
	(controller) edge (cursors)
      ;
    \end{tikzpicture}
    \end{center}
  \caption{Verwendete Klassen und Rolle des Controllers}
  \label{Grobentwurf}
  \end{figure}
  
  Die Besonderheit dieser Model-View-Controller Architektur ist, dass es nur einen zentrallen Controller gibt. Dadurch soll der Implementationsaufwand minimiert werden. Auf der rechten Seite sind die Models angeordnet, in der Mitte der Controller und auf der linken Seite die Views. Im folgendem wird kurz auf die Aufgaben der einzelnen Models eingegangen. Die Views bieten dem Nutzer jeweils die Interaktionsmöglichkeit an und der Controller setzt diese auf die Models um.

\subsubsection{Savable}

\subsubsection{Clock}
Diese Klasse ist der programminterne Zeitgeber. 
Das bedeutet, sie enthält in erste Linie den aktuellen Zeitpunkt des Programms in Bezug auf das Video beziehungsweise die Augenbewegungsdaten.

Alle Komponenten greifen direkt oder indirekt auf diese Instanz zurück wenn sie eine zeitveränderliche Eigenschaft abrufen. Daher gehen alle zeitlichen Steuerbefehle an die Instanz dieser Klasse, wie beispielsweise nächstes Frame oder vorherige Fixation. 

Zeitabhängige Komponenten können über die Funktion $register(function)$ gemäß des "`Observer Patterns"' über eine Veränderung der Zeit informiert werden.
Mit dieser Funktion wird biepsielsweise die GUI darüber informiert, dass sie das gezeigte Bild aktualisieren muss.

\subsubsection{VideoReader}
Die VideoReader Klasse ist für den Zugriff auf die Videobilder zuständig.

Der Klasse wird bei der Initialisierung der Ort der Videodatei bekannt gegeben und anschließend bietet sie framegenauen Zugriff und Informationen zum geladenen Video.

\subsubsection{VideoWriter}
Diese Klasse nimmt einzelne Bilder entgegen und speichert sie in einer Videodatei ab.

Dazu erhält sie bei der Initialisierung den Pfad der zu erstellenden Videodatei, die gewünschte Anzahl der Bilder pro Sekunde und den zu verwendenden Videocodec.
Das zu verwendende FOURCC Videocodec kann in der Konfigurationsdatei angegeben werden. Es ist wichtig, dass das angegebene FOURCC Codec auf dem System instaliert ist und der FOURCC Name korrekt ist. Ist dies nicht der Fall, erscheint eine Fehlermeldung.

\subsubsection{CategoryContainer}
Die CategoryContainer Klasse hält die Kategorien sowie die Zuordnung von Fixationen oder Frames zu Kategorien.

Bei der Initialisierung der Klasse wird festgelegt ob sie Fixationen oder Frames zu Kategorien zuordnet.

Anschließend bietet die Instanz Methoden, um die Kategorien zu verwalten (anlegen, Namen oder Tastenkürzel ändern, löschen), eine Fixation oder ein Frame einer Kategorie zuzuordnen, die Zuordnungen zu exportieren und um auf die beinhalteten Daten zuzugreifen.

\subsubsection{EyeMovement}
Die EyeMovement Klasse bereitet die Augenbewegungsdaten auf und bietet sie anderen Komponenten des Programms an.

Nachdem der Klasse bei der Initialisierung der Pfad zu einer Augenbewegungsdatendatei übergeben wurde, parst sie diese Datei und legt die enthaltenen Daten in internen Datenstrukturen an. Nun können andere Komponenten den Zustand der Augen zu einem bestimmten Zeitpunkt kategorisieren. Konkret kann folgendes abgerufen werden: Blickposition, Sakkade, Fixation oder Blinzeln jeweils des linken und rechten Auges und gemittelt für beide Augen.

\section{M\"ogliche Erweiterung}
  \begin{description}
    \item[Deinteralicing] Blablabla, opencv y u no deinterlacing?
  \end{description}

\section{Verwendete Python Module}
In den folgenden Abschnitten werden verwendete Python Module aufgezählt und kurz erklärt, wofür diese konkret in pyPsy verwendet werden. Dabei werden nur die Module erwähnt, die für die Funktionalität von pyPsy direkt notwendig sind und nicht häufig verwendete Module wie beispielsweise das "`os"' Modul. 
\subsection{OpenCV für Python}
Für die Verarbeitung von Videodateien und allen dazugehören Operationen wird OpenCV für Python verwendet, da es sehr viele Möglichkeiten bietet, gut dokumentiert und außerdem performant ist. 
Im Einzelnen wird OpenCV für das framebasierte Einlesen des Ausgangsvideos, das Zeichnen des Overlays (also der Augdaten) und das Erzeugen eines neuen Videos mit Overlay verwendet.
\subsection{Multiprocessing und Threading}
Diese beiden Module gewährleisten eine bessere Auslastung der Systemressourcen und dadurch eine flüssige Wiedergabe des Videos. 
In der Clock Klasse wird Threading verwendet, um einen nur für die Clock zuständigen Thread zu erzeugen. Dieser Thread bestimmt außerdem die Zeitrechnung der Clock, indem er für ein gewisses Interval schläft und erst danach weiter tickt. 
Multiprocessing wird in der start\_pypsy Klasse verwendet, um die Performance (evtl anderes wort?)von pyPsy weiter zu verbessern. Hierbei wird der Controller als Adapter zwischen den Model und den View Klassen verwendet, da nur über den Controller und das von ihm genutzte "` Shared Memory "' Daten von den Model Klassen zu den View Klassen und anders herum gelangen können. Dies geschieht unter anderem auch über "` Shared Variables "' des Controllers. 
Durch die Verwendung von Multiprocessing müssen folglich alle Daten und Variablen, auf die auch fremde Klassen zugreifen können sollen, dem Controller bekannt sein. Hierbei wird ein sogenannter "`Sync Manager"' aus dem Multiprocessing Modul verwendet und kein "`Process Pool"'.
Die Python Doku erklärt weitere Details zu Multiprocessing: \href{http://docs.python.org/library/multiprocessing.html}
{Multiprocessing}.
\url{http://docs.python.org/library/multiprocessing.html}
\subsection{Json für Python}
Um die vom Benutzer editierbare Config-Datei auslesen und schreiben zu können, verwendet pyPsy das Json Modul. Dies geschieht in der Config un in der Saveable Klasse. 

\subsection{Pickle}
Das Picke Modul wird in der Saveable Klasse verwendet, um die vom Benutzer generierten Kategorisierungen gut lesbar in einer csv-Datei abzuspeichern. Das Modul übernimmt dabei einen großen Teil der Arbeit des sogenannten Pretty-Printings, also der Formatierung.

\end{document}
